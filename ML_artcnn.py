# -*- coding: utf-8 -*-
"""ARTCNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gJhbh35vGFJ9TFlUl8CyYy8y2KBBdqkk
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import re
import os
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from keras.utils import to_categorical
from keras.optimizers import Adam
import cv2 as cv
import random

"""#1. 讀入封包"""

import random
import os 

if(os.path.isfile("./train.zip") == False):
  rand = random.randint(0,9)
  if (rand < 5):
    !wget -O train.zip "http://140.115.83.111/files/art/train.zip"
    !wget -O test.zip "http://140.115.83.111/files/art/test.zip"
    !echo "分流1"
  else:
    !wget -O train.zip "http://140.115.82.54/NN/ART/train.zip"
    !wget -O test.zip "http://140.115.82.54/NN/ART/test.zip"
    !echo "分流2"
  !unzip train.zip
  !unzip test.zip 
else:
  !echo "檔案已存在"

"""#2. 取得資料集"""

train_dir = "./train_resized/"
test_dir = "./test_resized/"
artists = pd.read_csv("./artists.csv")
num_classes = artists.shape[0]
print("Number of artists : ", num_classes)
artists.head()

artists = artists.loc[:, ["name", "paintings"]]
artists["name"] = artists["name"].str.split(" ").apply(lambda x: "_".join(x))
artists.head()

"""* **計算各個畫家畫作數量**
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
plt.figure(figsize=(10, 6))
barplot = sns.barplot(x='name', y='paintings', data=artists)
for item in barplot.get_xticklabels():
    item.set_rotation(90)

print("最多畫作為 : ", artists.paintings.max(), " 最少畫作為 : ", artists.paintings.min())

img_list = os.listdir(train_dir)
total_len = len(img_list)
random_list = random.sample(range(0, total_len), 20)
print("training 畫作總共畫作有 : ", total_len)

show_imgs = [img_list[rand] for rand in random_list]

plt.figure(figsize=(16, 16))
for index, imgName in enumerate(show_imgs):
    img_path = train_dir + imgName
    img = cv.imread(img_path)
    img = cv.cvtColor(img, cv.COLOR_BGR2RGB)
    plt.subplot(4, 5, index + 1)
    plt.imshow(img)
    plt.axis("off")
    plt.title("_".join(imgName.split("_")[:-1]))

"""## 3. 資料前處理

**有幾個重要的點需要處理**
1. 要取出 label : Claude_Monet
2. label (作者名稱)是英文，要先把英文映射成數字。EX: Van_Gogh --> 0 ; Edvard_Munch --> 1
3. label 數字還要轉成 50 depth 的 one_hot
* from_tensor_slices 可以輕鬆的讀取想要的資料，把圖片路徑傳入 tensor 後用 map 將路徑轉成圖片檔案。

"""
num_classes=50
# 英文映射成數字 dict。EX: Van_Gogh --> 0
def make_author_dict():
  char_to_index = {artists["name"][i]: i for i in range(len(artists["name"]))}
  return char_to_index

class_name = make_author_dict()
print(class_name)

# 數字映射成英文 dict。 EX: 0 --> Van_Gogh

def make_index_dict():
  index_to_char = {i: artists["name"][i] for i in range(len(artists["name"]))}
  return index_to_char

rev_class_name = make_index_dict()
print(rev_class_name)

def get_label(picName):
  picN = ''.join(filter(lambda x: not x.isdigit(), picName))[:-5]
  picLabel = class_name[picN]
  return picLabel

def get_path(dir,picName):
  img_path = dir + picName
  return img_path

def make_paths_label(dir):
  img_list = os.listdir(dir)
  paths = []
  labels = []
  for i in img_list:
    paths.append(get_path(dir, i))
    labels.append(get_label(i))
  onehot_labels = []
  for i in labels:
    one_hot_list = [0]*len(artists["name"])
    one_hot_list[i] = 1
    onehot_labels.append(one_hot_list)
  return paths, onehot_labels

# 查看
paths, onehot_labels = make_paths_label(train_dir)

print("paths : ")
for p in paths[:5]:
    print(p)
print("-" * 20)
print("labels : ")
for label in onehot_labels[:5]:
    print(label)

# 轉成 tensorflow dataset 格式，變成路徑 tensor
paths_ds = tf.data.Dataset.from_tensor_slices(paths)
train_label = tf.data.Dataset.from_tensor_slices(onehot_labels)

print("turn to tensor")
for tensor in paths_ds.take(5):
    print(tensor)

# 決定你輸入模型的圖片長寬
IMG_WIDTH = 256
IMG_HEIGHT = 256
IMG_SIZE = (IMG_WIDTH, IMG_HEIGHT)
# shuffle buffer size
SHUFFLE_BUFFER = 1000


def get_image(path):
    # read image from path
    file = tf.io.read_file(path)
    img = tf.io.decode_jpeg(file, channels=3)
    img = tf.cast(img, tf.float32)

    # 請固定每張圖片大小為 IMG_HEIGHT、IMG_WIDTH
    # 並將圖片每個 pixel 映射到 [0,1] 之間
    ##########
    img_resize = tf.image.resize(img, IMG_SIZE)/ 255.0
    ##########
    return img_resize


# 將所有資料轉成 Tensor -> Tensor 轉成圖片
# 圖片 Tensor 與 label Tensor Zip 起來成一個 pair
# shuffle 打散

def make_dataset(dir):
    paths, onehot_labels = make_paths_label(dir)
    paths_ds = tf.data.Dataset.from_tensor_slices(paths)
    train_label = tf.data.Dataset.from_tensor_slices(onehot_labels)
    # 將路徑 tensor 映射成圖片 tensor
    train_image = paths_ds.map(get_image)
    # 合併圖片與 label 資料集
    full_ds = tf.data.Dataset.zip((train_image, train_label))
    # 打散
    full_ds = full_ds.shuffle(SHUFFLE_BUFFER, reshuffle_each_iteration=False)
    return full_ds


full_ds = make_dataset(train_dir)

# 取出 Tensor 圖片來看看
plt.figure(figsize=(12, 8))
for index, (img, label) in enumerate(full_ds.take(6)):
    l = np.argmax(label.numpy())
    plt.subplot(2, 3, index + 1)
    plt.imshow(img)
    plt.title("Label number : {} \n Author Name : {}".format(l, rev_class_name[l]))
    plt.axis("off")

total_len = len(paths)
# 切割成 training data 與 validation data
train_len = int(0.8 * total_len)
val_len = total_len - train_len

train_ds = full_ds.take(train_len)
val_ds = full_ds.skip(train_len)

print("train size : ", train_len, " val size : ", val_len)

# 添加 batch
# todo
BATCH_SIZE = 64

train_ds = train_ds.batch(BATCH_SIZE)
val_ds = val_ds.batch(BATCH_SIZE)

# 查看添加batch後的維度
trainiter = iter(train_ds)
x, y = trainiter.next()
print("training image batch shape : ", x.shape)
print("training label batch shape : ", y.shape)

"""#建立模型

"""

artists
artists['class_weight'] = 
artists

#建weight dict
class_weights = artists['class_weight'].to_dict()
class_weights

input_shape = (IMG_WIDTH, IMG_HEIGHT, 3)

model = keras.Sequential(
    [
        keras.Input(shape=input_shape),
        layers.Conv2D(32, kernel_size=(3, 3), activation="relu", padding="same"),
        layers.MaxPooling2D(pool_size=(2, 2)),
        layers.Conv2D(64, kernel_size=(3, 3), activation="relu", padding="same"),
        layers.MaxPooling2D(pool_size=(2, 2)), 
        layers.Dropout(rate=0.9),
        layers.Flatten(),
        layers.Dense(256, activation="relu"),
        layers.Dropout(rate=0.2),
        layers.Dense(num_classes, activation="softmax"),
    ]
)

model.summary()

"""#訓練"""

epochs = 15

model.compile(loss="categorical_crossentropy", optimizer="Adam", metrics=["accuracy"])

history = model.fit(train_ds, epochs=epochs, validation_data=val_ds, class_weight=class_weights)

"""#評估模型"""

print(history.history.keys())

plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.title('model accuracy')
plt.ylabel('accuracy')
plt.xlabel('epoch')
plt.show()

plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')

plt.show()

# 讀入測試資料並評估模型
test_ds = make_dataset(test_dir)
test_ds = test_ds.batch(BATCH_SIZE)
score = model.evaluate(test_ds)
print("Test loss:", score[0])
print("Test accuracy:", score[1])

"""#做預測 """

def preditAuthor(img):
  # 寫個單圖片模型預測function
  # input : opencv img (height,width,3)
  # output : 某個作家名字 E.g. Claude_Monet
  #
  # 參考步驟:
  # 1. expand img dimension (height,width,3) -> (1,height,width,3)
  # 2. 丟入模型 model.predict
  # 3. 取出softmax後(50,) 取最大值的index作為辨識結果
  # 4. 將辨識結果轉為畫作家名字

  img = img.reshape(1, IMG_WIDTH, IMG_WIDTH, 3)
  authLabel = np.argmax(model.predict(img), axis=1)
  authorName = rev_class_name[authLabel[0]]
  ##########
  # todo #
  ##########
  return authorName

img_list = os.listdir(train_dir)
randomlist = random.sample(range(0,total_len), 20)
show_imgs = [img_list[rand] for rand in randomlist]
plt.figure(figsize=(8, 8))
for index,imgName in enumerate(show_imgs):
  imgpath = train_dir+imgName
  img = cv.imread(imgpath)
  img = cv.cvtColor(img,cv.COLOR_BGR2RGB)
  plt.subplot(4,5,index+1)
  plt.axis("off")
  plt.imshow(img)
  img = cv.resize(img,(IMG_WIDTH,IMG_HEIGHT))
  img = img / 255.0
  plt.title("True Author : {} \nPred Author : {}".format("_".join(imgName.split("_")[:-1]),preditAuthor(img)),size=6)

"""* 上傳圖片來試試看模型的效果"""

from google.colab import files


def upload_img():
    uploaded = files.upload()
    img_name = list(uploaded.keys())[0]
    img = cv.imread(img_name)
    img = cv.cvtColor(img, cv.COLOR_BGR2RGB)
    plt.imshow(img)
    img = cv.resize(img, (IMG_WIDTH, IMG_HEIGHT))
    img = img / 255.0
    return img


def eval():
    img = upload_img()
    plt.title("predict author : {}".format(preditAuthor(img)))
    plt.axis("off")
    plt.show()

eval()
